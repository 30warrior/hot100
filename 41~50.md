41.二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

<pre><strong>输入：</strong>root = [3,9,20,null,null,15,7]
<strong>输出：</strong>[[3],[9,20],[15,7]]
</pre>

**示例 2：**

<pre><strong>输入：</strong>root = [1]
<strong>输出：</strong>[[1]]
</pre>

**示例 3：**

<pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]</pre>

思路：用bfs确保一层一层遍历，然后在while循环里加入for循环来控制每个vector对应于每一层的节点。

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        if(root==nullptr) return ans;
        queue<TreeNode*> q;
        q.push(root);
        while(q.size())
        {
            ans.push_back(vector<int> ());
            int tmp = q.size();
            for(int i=0;i<tmp;i++)
            {
                TreeNode* a = q.front();
                q.pop();
                ans.back().push_back(a->val);
                if(a->left)
                q.push(a->left);
                if(a->right)
                q.push(a->right);
            }
        }
        return ans;
    }
};
```

42.将有序数组转化为二叉搜索树

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 平衡 二叉搜索树。

**示例 1：**

<pre><strong>输入：</strong>nums = [-10,-3,0,5,9]
<strong>输出：</strong>[0,-3,9,-10,null,5]
<strong>解释：</strong>[0,-10,5,null,-3,null,9] 也将被视为正确答案：
</pre>

**示例 2：**

<pre><strong>输入：</strong>nums = [1,3]
<strong>输出：</strong>[3,1]
<strong>解释：</strong>[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
</pre>

思路：用归并的思路，取当前数组中间位置作为当前根节点，然后左右分别构造左右子树。

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return build(nums,0,nums.size()-1);
    }
    TreeNode* build(vector<int>& nums,int left,int right)
    {
        if(left>right)
        return nullptr;
        int mid = (left + right) / 2;
        TreeNode* np = new TreeNode(nums[mid]);
        np->left = build(nums,left, mid-1);
        np->right = build(nums,mid+1,right);
        return np;
    }
};
```

43.验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

* 节点的左子树只包含 **严格小于** 当前节点的数。
* 节点的右子树只包含 **严格大于** 当前节点的数。
* 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

<pre><strong>输入：</strong>root = [2,1,3]
<strong>输出：</strong>true
</pre>

**示例 2：**

<pre><strong>输入：</strong>root = [5,1,4,null,null,3,6]
<strong>输出：</strong>false
<strong>解释：</strong>根节点的值是 5 ，但是右子节点的值是 4 。</pre>

思路：递归检查搜索树，用全局变量mins作为这个子树左边的最小值，如果mins比当前节点大则不是二叉搜索树。

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    long long mins = -2147483649;
    bool isValidBST(TreeNode* root) {
        if(root==nullptr) return true;
        bool left = isValidBST(root->left);
        if(left) cout<<1<<endl;
        bool now = true;
        if(mins >= root->val)
        now = false;
        if(now) cout<<2<<endl;
        mins = root->val;
        bool right = isValidBST(root->right);
        if(right) cout<<3<<endl;
        return now && left && right;
    }
};
```

44.二叉搜索树中第K小的数

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

**示例 1：**

<pre><strong>输入：</strong>root = [3,1,4,null,2], k = 1
<strong>输出：</strong>1
</pre>

**示例 2：**

<pre><strong>输入：</strong>root = [5,3,6,2,4,null,null,1], k = 3
<strong>输出：</strong>3</pre>

思路：通过dfs对整棵树进行中序遍历，然后将每个节点的值存入数组中

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> nums;
    void dfs(TreeNode* root)
    {
        if(root==nullptr)
        return;
        dfs(root->left);
        nums.push_back(root->val);
        dfs(root->right);
    }
    int kthSmallest(TreeNode* root, int k) {
        dfs(root);
        return nums[k-1];
    }
};
```

45.二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1：**

 **输入：** **root = [1,2,3,null,5,null,4]**

 **输出：** **[1,3,4]**

**示例 2：**

 **输入：** **root = [1,2,3,4,null,null,null,5]**

 **输出：** **[1,3,4,5]**

**示例 3：**

 **输入：** **root = [1,null,3]**

 **输出：** **[1,3]**

**示例 4：**

 **输入：** **root = []**

 **输出：** **[]**

思路：按层遍历二叉树，（优先遍历右边节点）

DFS版本：

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    void dfs(TreeNode* root,int s)
    {
        if(s==ans.size()) ans.push_back(root->val);
        if(root->right) dfs(root->right,s+1);
        if(root->left) dfs(root->left,s+1);
    }
    vector<int> rightSideView(TreeNode* root) {
        if(root) dfs(root,0);
        return ans;
    }
};
```

BFS版本：

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        if(root==nullptr) return ans;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            int tmp = q.size();
            ans.push_back(q.front()->val);
            for(int i=0;i<tmp;i++)
            {
                TreeNode* a = q.front();
                q.pop();
                if(a->right) q.push(a->right);
                if(a->left) q.push(a->left);
            }
        }
        return ans;
    }
};
```

46.二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

* 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
* 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin) 顺序相同

**示例 1：**

<pre><strong>输入：</strong>root = [1,2,5,3,4,null,6]
<strong>输出：</strong>[1,null,2,null,3,null,4,null,5,null,6]
</pre>

**示例 2：**

<pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>

**示例 3：**

<pre><strong>输入：</strong>root = [0]
<strong>输出：</strong>[0]
</pre>

思路：新建一个头节点，不断移动头节点来递归遍历二叉树，并修改二叉树的结构

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* head = new TreeNode();
    TreeNode* tmp = head;
    void flatten(TreeNode* root) {
        dfs(root);
        root = head->right;
    }
    void dfs(TreeNode* root)
    {
        if(root==nullptr) return;
        tmp->right = root;
        tmp = tmp->right;
        TreeNode* r = root->right;
        dfs(tmp->left);
        dfs(r);
        root->left = nullptr;
    }
};
```

47.从前序和中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的 **先序遍历** ， `inorder` 是同一棵树的 **中序遍历** ，请构造二叉树并返回其根节点。

**示例 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

<pre><strong>输入</strong><strong>:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
<strong>输出:</strong> [3,9,20,null,null,15,7]
</pre>

**示例 2:**

<pre><strong>输入:</strong> preorder = [-1], inorder = [-1]
<strong>输出:</strong> [-1]</pre>

思路：在中序遍历中找先序遍历的第一个元素，此时左边为左子树右边为右子树，从而在先序遍历中可以区分左右子树。不断递归来区分左右子树，但是在传递参数的时候需要注意，pr = pl + 左子树元素个数

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<int,int> mm;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        TreeNode* root = new TreeNode();
        for(int i=0;i<preorder.size();i++)
        mm[inorder[i]] = i;
        return dfs(preorder,inorder,0,preorder.size()-1,0,inorder.size()-1);
        // return root;
    }
    TreeNode* dfs(vector<int> preorder, vector<int> inorder,int pl,int pr,int il,int ir)
    {
        cout<<pl<<" "<<pr<<" "<<il<<" "<<ir<<endl;
        if(pl > pr || il > ir) return nullptr;
        int tmp = preorder[pl];
        int pos = mm[tmp];
        TreeNode* np = new TreeNode();
        np->val = tmp;
        int num = pos - il;
        np->left = dfs(preorder,inorder,pl+1,pl+num,il,pos-1);
        np->right = dfs(preorder,inorder,pl+num+1,pr,pos+1,ir);
        return np;
    }
};
```

48.路径总和Ⅲ

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例 1：**

<pre><strong>输入：</strong>root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
<strong>输出：</strong>3
</pre>

**示例 2：**

<pre><strong>输入：</strong>root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
<strong>输出：</strong>3</pre>

思路：用一个哈希表记录每个出现过的前缀和的个数（键和值分别为前缀和以及出现次数），然后在dfs过程中记录当前前缀和，判断是否有满足条件的路径，并将新的前缀和加入到哈希表中，最后需要回溯，将哈希表中这个前缀和删除，因为后面遍历不经过这个节点了，而哈希表记录的是以这个节点为起点的路径长度。

超级难题！！！

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<long long,int> prefix; //键和值分别为前缀和以及出现的次数
    int pathSum(TreeNode* root, int targetSum) {
        int ans = 0;
        prefix[0] = 1;
        long long sum = 0;
        dfs(root,targetSum,sum,ans);
        return ans;
    }
    void dfs(TreeNode* root, int targetSum, long long cur, int &ans)
    {
        if(!root) return;
        cur += root->val;
        if(prefix.find(cur - targetSum) != prefix.end())
        ans += prefix[cur - targetSum];
        // 存在满足条件的路径
        prefix[cur]++;
        dfs(root->left,targetSum,cur,ans);
        dfs(root->right,targetSum,cur,ans);
        prefix[cur]--;
        //以当前节点为起点的路径已经走完了，后面不再以其为起点，所以回溯
        //因为路径是从上到下寻找的
    }
};
```

49.二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ **一个节点也可以是它自己的祖先** ）。”

**示例 1：**

<pre><strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
<strong>输出：</strong>3
<strong>解释：</strong>节点 5 和节点 1 的最近公共祖先是节点 3 。
</pre>

**示例 2：**

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

<pre><strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
<strong>输出：</strong>5
<strong>解释：</strong>节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
</pre>

**示例 3：**

<pre><strong>输入：</strong>root = [1,2], p = 1, q = 2
<strong>输出：</strong>1</pre>

思路1：用一个哈希表记录每个节点的父亲，另一个记录节点p到根节点之间的每个节点。然后q不断向上移动，直到出现一个节点在p和根节点的路径之间，那么这个节点就是他们的最近公共祖先节点。

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    unordered_map<int,TreeNode*> fa;
    unordered_map<int,int> vis;
    void dfs(TreeNode* root)
    {
        if(root==NULL) return;
        if(root->left)
        {
            fa[root->left->val] = root;
            dfs(root->left);
        }
        if(root->right)
        {
            fa[root->right->val] = root;
            dfs(root->right);
        }
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL || root==p || root==q) return root;
        dfs(root);
        while(p)
        {
            vis[p->val] = 1;
            p = fa[p->val];
        }
        while(q)
        {
            if(vis[q->val])
            return q;
            q = fa[q->val];
        }
        return NULL;
    }
};
```

思路2：p和q要么在公共祖先的同一侧子树下，要么在不同侧子树下，所以从根节点开始依次往下遍历，每个节点都作为可能的公共祖先往下递归

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL || root==p || root==q) return root;
        TreeNode* l = lowestCommonAncestor(root->left,p,q);
        TreeNode* r = lowestCommonAncestor(root->right,p,q);
        if(l && r) return root;
        return l ? l : r;
    }
};
```

50.二叉树中的最大路径长度

二叉树中的**路径**被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径** 至少包含一个 **节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

<pre><strong>输入：</strong>root = [1,2,3]
<strong>输出：</strong>6
<strong>解释：</strong>最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6</pre>

**示例 2：**

<pre><strong>输入：</strong>root = [-10,9,20,null,null,15,7]
<strong>输出：</strong>42
<strong>解释：</strong>最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42</pre>

思路：用一个全局变量记录最大路径长度，然后递归遍历路径，需要注意向上递归的时候，返回的值只有当前节点值和左右子树的最大值之和，也就是不可能返回tmp，tmp只用于更新最大路径长度

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int f = INT_MIN;
    int maxPathSum(TreeNode* root) {
        if(root==nullptr) return 0;
        dfs(root);
        return f;
    }
    int dfs(TreeNode* root)
    {
        if(root==nullptr) return 0;
        int ansl = max(dfs(root->left),0);
        int ansr = max(dfs(root->right),0);
        int tmp = root->val + ansl + ansr;
        f = max(f,tmp);
        // cout<<ans<<" "<<tmp<<endl;
        return max(ansl,ansr) + root->val;
    }
};
```
