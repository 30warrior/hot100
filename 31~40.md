31.K个一组翻转链表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**

<pre><strong>输入：</strong>head = [1,2,3,4,5], k = 2
<strong>输出：</strong>[2,1,4,3,5]
</pre>

**示例 2：**

<pre><strong>输入：</strong>head = [1,2,3,4,5], k = 3
<strong>输出：</strong>[3,2,1,4,5]</pre>

思路：用栈存储节点，当栈内节点数等于K，将其依次读出，接到头节点，最后将剩余的节点再接到末尾。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode *dummy = new ListNode();
        ListNode *tmp = dummy;
        stack<ListNode*> s;
        ListNode *p = head;
        ListNode *left = p;
        while(p!=nullptr)
        {
            s.push(p);
            p = p->next;
            if(s.size()==k)
            {
                left = p;
                while(s.size())
                {
                    dummy->next = s.top();
                    s.pop();
                    dummy = dummy->next;
                }
            }
        }
        dummy->next = left;
        return tmp->next;
    }
};
```

32.随机链表的复制

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的  **[深拷贝](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)** 。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。 **复制链表中的指针都不应指向原链表中的节点 ** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

* `val`：一个表示 `Node.val` 的整数。
* `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为  `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

**示例 1：**

<pre><strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
<strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]
</pre>

**示例 2：**

<pre><strong>输入：</strong>head = [[1,1],[2,1]]
<strong>输出：</strong>[[1,1],[2,1]]
</pre>

**示例 3：**

<pre><strong>输入：</strong>head = [[3,null],[3,0],[3,null]]
<strong>输出：</strong>[[3,null],[3,0],[3,null]]</pre>

思路：用哈希表存储旧链表和新链表节点之间的关系，然后通过递归，更新新链表节点的next和random

```
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
  
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    unordered_map<Node*,Node*> m;
    Node* copyRandomList(Node* head) {
        if(head==NULL)
        {
            return NULL;
        }
        if(!m.count(head))
        {
            Node* newhead = new Node(head->val);
            m[head] = newhead;
            newhead->next = copyRandomList(head->next);
            newhead->random = copyRandomList(head->random);
        }
        return m[head];
    }
};
```

33.排序链表

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

<pre><b>输入：</b>head = [4,2,1,3]
<b>输出：</b>[1,2,3,4]
</pre>

**示例 2：**

<pre><b>输入：</b>head = [-1,5,3,4,0]
<b>输出：</b>[-1,0,3,4,5]
</pre>

**示例 3：**

<pre><b>输入：</b>head = []
<b>输出：</b>[]</pre>

思路：链表排序只能使用归并排序，每次取当前链表段的中点，然后分成两段，不断递归，直到只剩下一个节点，再不断将其合并。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head==nullptr || head->next ==nullptr)
        return head;

        ListNode* mid = getmid(head);
        ListNode* midnext = mid->next;
        mid->next = nullptr;
        ListNode* left = sortList(head);
        ListNode* right = sortList(midnext);
        return merge(left,right);
    }

    ListNode* getmid(ListNode* head)
    {
        ListNode *slow = head, *fast = head->next;
        while(fast!=nullptr && fast->next!=nullptr)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    ListNode* merge(ListNode* left, ListNode* right)
    {
        ListNode* dummy = new ListNode(0);
        ListNode* tmp = dummy;
        while(left!=nullptr && right!=nullptr)
        {
            if(left->val < right->val)
            {
                tmp->next = left;
                left = left->next;
            }
            else{
                tmp->next = right;
                right = right->next;
            }
            tmp = tmp->next;
        }
        if(left!=nullptr) tmp->next = left;
        else if(right!=nullptr) tmp->next = right;
        return dummy->next;
    }
};
```

34.合并K个升序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

<pre><strong>输入：</strong>lists = [[1,4,5],[1,3,4],[2,6]]
<strong>输出：</strong>[1,1,2,3,4,4,5,6]
<strong>解释：</strong>链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
</pre>

**示例 2：**

<pre><strong>输入：</strong>lists = []
<strong>输出：</strong>[]
</pre>

**示例 3：**

<pre><strong>输入：</strong>lists = [[]]
<strong>输出：</strong>[]</pre>

思路：用上一题的思路，对链表进行两两合并

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists,0,lists.size()-1);
    }

    ListNode* merge2Lists(ListNode* l,ListNode* r){
        if(l==nullptr) return r;
        if(r==nullptr) return l;
        ListNode *head = new ListNode(0);
        ListNode *tmp = head;
        while(l!=nullptr && r!=nullptr)
        {
            if(l->val < r->val)
            {
                tmp->next = l;
                l = l->next;
            }
            else{
                tmp->next = r;
                r = r->next;
            }
            tmp = tmp->next;
        }
        tmp->next = l==nullptr ? r : l;
        return head->next;
    }

    ListNode* merge(vector<ListNode*> &lists, int l,int r)
    {
        if(l==r) return lists[l];
        if(l>r) return nullptr;
        int m = (l+r)/2;
        return merge2Lists(merge(lists,l,m),merge(lists,m+1,r));
    }
};
```

36.二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

**示例 1：**

<pre><strong>输入：</strong>root = [1,null,2,3]
<strong>输出：</strong>[1,3,2]
</pre>

**示例 2：**

<pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]
</pre>

**示例 3：**

<pre><strong>输入：</strong>root = [1]
<strong>输出：</strong>[1]
</pre>

思路：通过dfs对二叉树进行遍历，并根据遍历顺序将节点存入向量中

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> ans;
    void dfs(TreeNode* root)
    {
        if(root==nullptr) return;
        if(root->left)
        {
            dfs(root->left);
        }
        ans.push_back(root->val);
        if(root->right)
        {
            dfs(root->right);
        }
    }
    vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return ans;
    }
};
```

37.二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

<pre><b>输入：</b>root = [3,9,20,null,null,15,7]
<b>输出：</b>3
</pre>

**示例 2：**

<pre><b>输入：</b>root = [1,null,2]
<b>输出：</b>2</pre>

思路：用dfs遍历二叉树，二叉树的深度=左子树、右子树深度最大值+1

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        return dfs(root);
    }
    int dfs(TreeNode* root)
    {
        if(root==nullptr)
        return 0;
        return max(dfs(root->left),dfs(root->right))+1;
    }
};
```

38.翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

<pre><strong>输入：</strong>root = [4,2,7,1,3,6,9]
<strong>输出：</strong>[4,7,2,9,6,3,1]
</pre>

**示例 2：**

<pre><strong>输入：</strong>root = [2,1,3]
<strong>输出：</strong>[2,3,1]
</pre>

**示例 3：**

<pre><strong>输入：</strong>root = []
<strong>输出：</strong>[]</pre>

思路：一路递归到叶节点，然后往上走，不断翻转左右子树

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr)
        return nullptr;
        TreeNode* left = invertTree(root->left);
        TreeNode* right = invertTree(root->right);
        root->left = right;
        root->right = left;
        return root;
    }
};
```

39.对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

<pre><strong>输入：</strong>root = [1,2,2,3,4,4,3]
<strong>输出：</strong>true
</pre>

**示例 2：**

<pre><strong>输入：</strong>root = [1,2,2,null,3,null,3]
<strong>输出：</strong>false</pre>

思路：递归，检查轴对称的两棵子树是否对称。

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool check(TreeNode* a,TreeNode* b)
    {
        if(a==nullptr && b==nullptr) return true;
        if(!a && b || a && !b) return false;
        if(a->val != b->val) return false;
        return a->val==b->val && check(a->left, b->right) && check(a->right, b->left);
    }

    bool isSymmetric(TreeNode* root) {
        return check(root->left,root->right);
    }
};
```

40.二叉树的直径

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

**示例 1：**

<pre><strong>输入：</strong>root = [1,2,3,4,5]
<strong>输出：</strong>3
<strong>解释：</strong>3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
</pre>

**示例 2：**

<pre><strong>输入：</strong>root = [1,2]
<strong>输出：</strong>1</pre>

思路：直径可以理解为某一结点的左子树深度和右子树深度之和，所以采用dfs，不断搜索左右节点子树长度，并更新直径大小

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans=0;
    int dfs(TreeNode* root)
    {
        if(root==nullptr) return 0;
        int left = dfs(root->left);
        int right = dfs(root->right);
        // cout<<ans<<" ";
        ans = max(left + right,ans);
        return max(left,right)+1;
    }
    int diameterOfBinaryTree(TreeNode* root) {
        int a=dfs(root);
        return ans;
    }
};
```
