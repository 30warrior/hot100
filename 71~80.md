71.每日温度

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替

**示例 1:**

<pre><strong>输入:</strong> temperatures = [73,74,75,71,69,72,76,73]
<strong>输出:</strong> [1,1,4,2,1,1,0,0]
</pre>

**示例 2:**

<pre><strong>输入:</strong> temperatures = [30,40,50,60]
<strong>输出:</strong> [1,1,1,0]
</pre>

**示例 3:**

<pre><strong>输入:</strong> temperatures = [30,60,90]
<strong>输出: </strong>[1,1,0]</pre>

思路：用单调栈存放每一天，然后在遍历时比较栈顶元素（第i天）的温度是否小于当前温度，如果小于则修改ans并弹出该元素。

最开始写的时候未考虑到temperature并不需要存入栈内。

```
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int len = temperatures.size();
        if(!len) return {};
        stack<pair<int,int>> s;
        vector<int> ans(len);
        for(int i=0;i<len;i++)
        {
            cout<<i<<endl;
            while(s.size()){
                int t = s.top().first,day = s.top().second;
                if(t < temperatures[i]){
                    ans[day] = i-day;
                    s.pop();
                }
                else break;
            }
            s.push({temperatures[i],i});
        }
        return ans;
    }
};
```

72.数组中的第K个最大元素

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k`个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

<pre><strong>输入:</strong> [3,2,1,5,6,4], k = 2
<strong>输出:</strong> 5
</pre>

**示例 2:**

<pre><strong>输入:</strong> [3,2,3,1,2,4,5,5,6], k = 4
<strong>输出:</strong> 4</pre>

思路：用递归的方式，每次递归都将数组根据和基准数的大小关系分为三个部分，然后根据三个部分和k的大小情况选择跳转到哪个部分继续递归。

```
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        return dfs(nums,k);
    }
    int dfs(vector<int> &nums,int k){
        int tmp = nums[rand() % nums.size()];
        vector<int> s,e,b;
        for(int i : nums)
        {
            if(i < tmp)
            s.push_back(i);
            else if (i > tmp)
            b.push_back(i);
            else e.push_back(i);
        }
        if(k <= b.size())
        return dfs(b,k);
        if(k > nums.size()-s.size())
        return dfs(s,k-nums.size()+s.size());
        return tmp;
    }
};
```

73.前K个高频元素

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1：**

 **输入：** **nums = [1,1,1,2,2,3], k = 2**

 **输出：** **[1,2]**

**示例 2：**

 **输入：** **nums = [1], k = 1**

 **输出：** **[1]**

**示例 3：**

 **输入：** **nums = [1,2,1,2,1,2,3,1,3,2], k = 2**

 **输出：** **[1,2]**

思路：首先用哈希表存储每个元素出现的次数，然后用优先队列确保进队元素按序排列，当对内元素少于k，直接进队，否则需要比较栈顶元素和当前元素出现次数的大小。

```
class Solution {
public:
    static bool cmp(pair<int,int> a,pair<int,int> b){
        return a.second > b.second;
    }
    vector<int> topKFrequent(vector<int>& nums, int k) {
        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(&cmp)> q(cmp);
        unordered_map<int,int> s;
        for(int i : nums)
        {
            s[i]++;
        }
        for(auto [num,count] : s)
        {
            if(q.size() < k)
            q.emplace(num,count);
            else{
                if(q.top().second < count){
                    q.pop();
                    q.emplace(num,count);
                }
            }
        }
        vector<int> ans;
        while(q.size()){
            ans.push_back(q.top().first);
            q.pop();
        }
        return ans;
    }
};
```
