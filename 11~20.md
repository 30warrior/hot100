11.滑动窗口最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

**示例 1：**

<pre><b>输入：</b>nums = [1,3,-1,-3,5,3,6,7], k = 3
<b>输出：</b>[3,3,5,5,6,7]
<b>解释：</b>
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       <strong>3</strong>
 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>
 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>
 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>
 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>
 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>
</pre>

**示例 2：**

<pre><b>输入：</b>nums = [1], k = 1
<b>输出：</b>[1]</pre>

思路：使用优先队列，从而在logn时间内找到窗口中最大的数；然后需要记录下这个数的下标。在窗口移动时，如果最左端的不是最大的数，那么是没办法将其删除的（因为不在队首），当最大的数已经不在窗口内时，将其删除，但删除后的队列中最大的数可能也是不在窗口内的！！！

```
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int,int>> q;
        vector<int> ans;
        int len = nums.size();
        for(int i=0;i<k;i++)
        {
            q.push({nums[i],i});
        }
        ans.push_back(q.top().first);
        for(int i=k;i<len;i++)
        {
            q.push({nums[i],i});
            while(q.top().second <= i-k)
            q.pop();
            ans.push_back(q.top().first);
        }
        return ans;
    }
};
```

12.最长覆盖子串

13.最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分

**示例 1：**

<pre><strong>输入：</strong>nums = [-2,1,-3,4,-1,2,1,-5,4]
<strong>输出：</strong>6
<strong>解释：</strong>连续子数组 [4,-1,2,1] 的和最大，为 6 。
</pre>

**示例 2：**

<pre><strong>输入：</strong>nums = [1]
<strong>输出：</strong>1
</pre>

**示例 3：**

<pre><strong>输入：</strong>nums = [5,4,-1,7,8]
<strong>输出：</strong>23</pre>

思路：用动态规划，得出到下标为i的位置时的最大子数组和为 max ( ans[i-1] + nums[i], nums[i] )

```
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int len = nums.size();
        vector<int> ans(len,-1e5);
        ans[0] = nums[0];
        for(int i=1;i<len;i++)
        {
            ans[i] = max(ans[i-1] + nums[i], nums[i]);
        }
        int maxans = -1e5;
        for(int i=0;i<len;i++)
        maxans = max(maxans,ans[i]);
        return maxans;
    }
};
```

14.合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

<pre><strong>输入：</strong>intervals = [[1,3],[2,6],[8,10],[15,18]]
<strong>输出：</strong>[[1,6],[8,10],[15,18]]
<strong>解释：</strong>区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
</pre>

**示例 2：**

<pre><strong>输入：</strong>intervals = [[1,4],[4,5]]
<strong>输出：</strong>[[1,5]]
<strong>解释：</strong>区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>

**示例 3：**

<pre><b>输入：</b>intervals = [[4,7],[1,4]]
<b>输出：</b>[[1,7]]
<b>解释：</b>区间 [1,4] 和 [4,7] 可被视为重叠区间。</pre>

思路：首先进行排序，然后依次遍历每段区间，判断是否连续的区间之间存在重叠部分，如果存在就将其合并，同时用while不断与下一个区间进行判断，直至不存在重叠部分，此时将这个区间存入ans。最后还需要判断是否最后一个区间需要放入ans。

```
class Solution {
public:
    bool cmp(vector<int> a,vector<int> b)
    {
        return a[0] < b[0];
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(),intervals.end());
        vector<vector<int>> ans;
        int len = intervals.size(),i=0,f=0;
        while(i < len-1)
        {
            while(i < len-1 && intervals[i][1] >= intervals[i+1][0]){
                intervals[i+1][0] = intervals[i][0];
                intervals[i+1][1] = max(intervals[i+1][1],intervals[i][1]);
                cout<<intervals[i+1][0]<<", "<<intervals[i+1][1]<<endl;
                i++;
                if(i==len-1){
                    f=1;
                }
            }
            ans.push_back(intervals[i]);
            i++;
        }
        if(f==0)
        ans.push_back(intervals[len-1]);
        return ans;
    }
};
```

15.轮转数组

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

<pre><strong>输入:</strong> nums = [1,2,3,4,5,6,7], k = 3
<strong>输出:</strong> <code>[5,6,7,1,2,3,4]</code>
<strong>解释:</strong>
向右轮转 1 步: <code>[7,1,2,3,4,5,6]</code>
向右轮转 2 步: <code>[6,7,1,2,3,4,5]
</code>向右轮转 3 步: <code>[5,6,7,1,2,3,4]</code>
</pre>

**示例 2:**

<pre><strong>输入：</strong>nums = [-1,-100,3,99], k = 2
<strong>输出：</strong>[3,99,-1,-100]
<strong>解释:</strong> 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]</pre>

思路：计算出需要遍历的圈数为gcd (k,len)，然后不断将数组下标为t处的值与t+k处的交换位置，直到一圈走完，然后走另外的一圈。

```
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int len = nums.size();
        k = k%len;
        int count = gcd(k, len);
        for (int start = 0; start < count; ++start) {
            int current = start;
            int prev = nums[start];
            do {
                int next = (current + k) % len;
                swap(nums[next], prev);
                current = next;
            } while (start != current);
        }
    }
};
```

16.除自身外数组的乘积

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请  **不要使用除法，** 且在 `O(n)` 时间复杂度内完成此题。

**示例 1:**

<pre><strong>输入:</strong> nums = <code>[1,2,3,4]</code>
<strong>输出:</strong> <code>[24,12,8,6]</code>
</pre>

**示例 2:**

<pre><strong>输入:</strong> nums = [-1,1,0,-3,3]
<strong>输出:</strong> [0,0,9,0,0]</pre>

思路：首先用ans数组记录下标为i处左边的所有数字的乘积，然后从右往左遍历，记录下标为i处右边的所有数字的乘积，并与ans [i] 相乘，得到结果。

```
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int len = nums.size(),sum = 1;
        vector<int> ans(len);
        ans[0] = 1;
        for(int i=1;i<len;i++)
        {
            ans[i] = ans[i-1] * nums[i-1];
        }
        int x=1;
        for(int i=len-1;i>=0;i--)
        {
            ans[i] = ans[i] * x;
            x *= nums[i];
        }
        return ans;
    }
};
```

17.缺失的第一个正数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**示例 1：**

<pre><strong>输入：</strong>nums = [1,2,0]
<strong>输出：</strong>3
<strong>解释：</strong>范围 [1,2] 中的数字都在数组中。</pre>

**示例 2：**

<pre><strong>输入：</strong>nums = [3,4,-1,1]
<strong>输出：</strong>2
<strong>解释：</strong>1 在数组中，但 2 没有。</pre>

**示例 3：**

<pre><strong>输入：</strong>nums = [7,8,9,11,12]
<strong>输出：</strong>1
<strong>解释：</strong>最小的正数 1 没有出现。</pre>

思路：用哈希表记录数组中每个正数，然后从1开始检查是否在表中。

```
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        unordered_set<int> ss;
        int len = nums.size();
        for(int i=0;i<len;i++)
        {
            if(nums[i]>0)
            ss.insert(nums[i]);
        }
        int ans=1;
        while(1){
            if(ss.find(ans)==ss.end())
            return ans;
            else ans++;
        }
        return 0;
    }
};
```

思路：将数组进行交换，使得x=nums[i]出现在下标为i-1处，然后依次遍历数组，只要nums[i]!=i+1则i+1缺失

```
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums[nums[i] - 1], nums[i]);
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
};
```



18.矩阵置零

给定一个m x n 的矩阵，如果一个元素为  **0 ** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 算法

**示例 1：**

<pre><strong>输入：</strong>matrix = [[1,1,1],[1,0,1],[1,1,1]]
<strong>输出：</strong>[[1,0,1],[0,0,0],[1,0,1]]</pre>

**示例 2：**

<pre><strong>输入：</strong>matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
<strong>输出：</strong>[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</pre>

思路：用两个向量，分别记录每一行和每一列是否存在0，然后遍历一遍矩阵，只要检查到这一行/列存在零，则将这个位置置零

```
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        vector<int> mm(m),nn(n);
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(!matrix[i][j])
                mm[i]=1, nn[j]=1;
            }
        }
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(mm[i] || nn[j])
                matrix[i][j]=0;
            }
        }
    }
};
```



19.螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

**示例 1：**

<pre><strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>输出：</strong>[1,2,3,6,9,8,7,4,5]</pre>

**示例 2：**

<pre><strong>输入：</strong>matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
<strong>输出：</strong>[1,2,3,4,8,12,11,10,9,5,6,7]</pre>

思路：有点类似bfs，通过mx和my的顺序，规定遍历矩阵的顺序，然后不断更新未遍历的矩阵的维度

```
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size(), sm = 0, sn = 0;
        int a = n * m;
        int mx[4] = {0,1,0,-1}, my[4] = {1,0,-1,0};
        vector<int> ans;
        int i=0,j=0,index=0;
        while(a)
        {
            ans.push_back(matrix[i][j]);
            a--;
            int ti = i + mx[index];
            int tj = j + my[index];
            if(ti < sm || tj < sn || ti >= m || tj >= n){
                if(index==0)
                sm++;
                else if(index==1)
                n--;
                else if(index==2)
                m--;
                else if(index==3)
                sn++;
                ti = ti - mx[index];
                tj = tj - my[index];
                index = (index + 1) % 4;
                ti = ti + mx[index];
                tj = tj + my[index];
            }
            i = ti, j = tj;
        }
        return ans;
    }
};
```



20.旋转图像

给定一个  n  × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要 **使用另一个矩阵来旋转图像。

**示例 1：**

<pre><strong>输入：</strong>matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>输出：</strong>[[7,4,1],[8,5,2],[9,6,3]]
</pre>

**示例 2：**

<pre><strong>输入：</strong>matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
<strong>输出：</strong>[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</pre>

思路：通过数学公式推导顺时针旋转时，各个元素的变化情况，然后遍历旋转

```
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int right = m;
        for(int i = 0;i<m/2;i++)
        {
            for(int j=0;j<(m+1)/2;j++)
            {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[m-1-j][i];
                matrix[m-1-j][i] = matrix[m-1-i][m-1-j];
                matrix[m-1-i][m-1-j] = matrix[j][right-1-i];
                matrix[j][right-1-i] = tmp;
            }
        }
    }
};
// 1,0 -- 0,2   2,1 -- 1,1
```
