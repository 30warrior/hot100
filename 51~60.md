51.岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

<pre><strong>输入：</strong>grid = [
  ['1','1','1','1','0'],
  ['1','1','0','1','0'],
  ['1','1','0','0','0'],
  ['0','0','0','0','0']
]
<strong>输出：</strong>1
</pre>

**示例 2：**

<pre><strong>输入：</strong>grid = [
  ['1','1','0','0','0'],
  ['1','1','0','0','0'],
  ['0','0','1','0','0'],
  ['0','0','0','1','1']
]
<strong>输出：</strong>3</pre>

思路：当检测到某个点为‘1’，就用dfs搜索邻近的‘1’，同时将其变为2，从而防止了重复遍历。执行了几次dfs，就有几个岛屿

```
class Solution {
public:
    int mx[4] = {0,0,1,-1},my[4] = {1,-1,0,0};
    void dfs(int x,int y,int m,int n,vector<vector<char>>& grid)
    {
        for(int i=0;i<4;i++)
        {
            int dx = x + mx[i], dy = y + my[i];
            if(dx<0 || dy<0 || dx >= m || dy >=n || grid[dx][dy]!='1')
            continue;
            grid[dx][dy]='2';
            dfs(dx,dy,m,n,grid);
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        int ans = 0;
        int m = grid.size(), n = grid[0].size(); 
        for(int i=0;i<grid.size();i++)
        {
            for(int j=0;j<grid[0].size();j++)
            {
                if(grid[i][j] == '1')
                {
                    dfs(i,j,m,n,grid);
                    ans++;
                }
            }
        }
        return ans;
    }
};
```

52.腐烂的橘子

在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：

* 值 `0` 代表空单元格；
* 值 `1` 代表新鲜橘子；
* 值 `2` 代表腐烂的橘子。

每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。

返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`*

**示例 1：**

<pre><strong>输入：</strong>grid = [[2,1,1],[1,1,0],[0,1,1]]
<strong>输出：</strong>4
</pre>

**示例 2：**

<pre><strong>输入：</strong>grid = [[2,1,1],[0,1,1],[1,0,1]]
<strong>输出：</strong>-1
<strong>解释：</strong>左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。
</pre>

**示例 3：**

<pre><strong>输入：</strong>grid = [[0,2]]
<strong>输出：</strong>0
<strong>解释：</strong>因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</pre>

思路：将每个腐烂的橘子放入队列，然后用bfs进行遍历，用类似于二叉树的逐层遍历的方式，从而获取最后一层的深度，这就是答案，同时需要判断是否所有橘子都变腐烂了

```
class Solution {
public:
    queue<pair<int,int>> q;
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        if(m==1 && n==1 && grid[0][0] != 1) return 0;
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]==2) q.push({i,j});
            }
        }
        int ans = bfs(grid);
        return ans;
    }
    int bfs(vector<vector<int>>& grid)
    {
        int m = grid.size(),n = grid[0].size();
        int mx[4] = {0,0,1,-1},my[4] = {1,-1,0,0};
        int t = 0;
        while(q.size())
        {
            int tmp = q.size();
            cout<<tmp;
            for(int i=0;i<tmp;i++)
            {
                int x = q.front().first, y = q.front().second;
                q.pop();
                for(int j=0;j<4;j++)
                {
                    int dx = x + mx[j], dy = y + my[j];
                    if(dx<0 || dy<0 || dx>=m || dy>=n || grid[dx][dy]!=1) continue;
                    grid[dx][dy] = 2;
                    q.push({dx,dy});
                }
            }
            t++;
        }
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            if(grid[i][j] == 1) return -1;
        }
        if(t) t--;
        return t;
    }
};
```

53.课程表

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]` ，表示如果要学习课程 `a<sub>i</sub>` 则 **必须** 先学习课程  `b<sub>i</sub>` ~ ~ 。

* 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

<pre><strong>输入：</strong>numCourses = 2, prerequisites = [[1,0]]
<strong>输出：</strong>true
<strong>解释：</strong>总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</pre>

**示例 2：**

<pre><strong>输入：</strong>numCourses = 2, prerequisites = [[1,0],[0,1]]
<strong>输出：</strong>false
<strong>解释：</strong>总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</pre>

思路1：用向量组e存储每个课程的后继，然后用vis检测一个课程是否已经被遍历过，然后dfs递归搜索是否出现环

```
class Solution {
public:
    bool f = true;  
    vector<vector<int>> e;
    vector<int> vis;
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        e.resize(numCourses);
        vis.resize(numCourses);
        for(auto i : prerequisites)
        {
            e[i[1]].push_back(i[0]);
        }
        for(int i=0;i<numCourses;i++)
        {
            if(!f) return f;
            if(!vis[i])
            {
                dfs(i);
            }
        }
        return f;
    }
    void dfs(int x)
    {
        vis[x] = 1;
        for(int i : e[x])
        {
            if(!vis[i]){
                dfs(i);
                if(!f) return;
            }
            else if(vis[i]==1){
                f=false;
                return;
            }
        }
        vis[x]=2;
        return;
    }
};
```

思路2：拓扑排序，用in数组记录每个课程的入度，out数组记录每个课程的后继。然后按照拓扑，不断删除入度为0的点（其实类似于学习不用先导课程的课程），然后检查是否有新的不需要先导课程的课程，将其放入队列。如果最后可以把所有点都消除，说明可以完成所有课程的学习；如果while循环过程中，出现了环，就会导致队列为空，此时也无法完成所有课程。

```
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        int course[2005];
        int in[2005];
        vector<int> out[2005];
        for(int i=0;i<2005;i++)
            course[i]=in[i]=0;
        for(int i=0;i<prerequisites.size();i++)
        {
            int a = prerequisites[i][0],b = prerequisites[i][1];
            in[a]++;
            out[b].push_back(a);
        }
        int num_in = numCourses,start;
        queue<int> q;
        int num=0;
        for(int i=0;i<num_in;i++)
        {
            if(in[i]==0)
            {
                cout<<i<<" ";
                start = i;
                num++;
                q.push(start);
            }
        }
        if(q.empty())
        return false;
        // for(int i=0;i<numCourses;i++)
        //     cout<<in[i]<<" ";
        while(1){
            if(q.empty())
            return false;
            int head = q.front();
            cout<<head<<endl;
            q.pop();
            for(int i=0;i<out[head].size();i++)
            {
                int c = out[head][i];
                in[c]--;
                if(in[c]==0){
                    q.push(c);
                    num++;
                }
            }
            if(num==numCourses)
                return true;
        }
        return false;
    }
};
```

54.实现Trie（前缀树）

 **[Trie](https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin)** （发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

* `Trie()` 初始化前缀树对象。
* `void insert(String word)` 向前缀树中插入字符串 `word` 。
* `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
* `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

**示例：**

<pre><strong>输入</strong>
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
<strong>输出</strong>
[null, null, true, false, true, null, true]

<strong>解释</strong>
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True</pre>

思路：用26个类指针，指向每个可能的后续字母；end用于判断这个字母是否为单词的末尾。insert：在创建的时候，不断判断是否已经有了这个前缀，只有在没有对应前缀的时候创建新的Trie，并且在单词末尾，需要修改end。search：流程类似insert，但是当遇到某个字母并不存在的时候，直接返回false，并且每个字母都匹配，也需要判断是否此时为前缀树的末尾（end为true）。startsWith：相较于search，少了end的判断。

```
class Trie {
public:
    bool end;
    Trie* next[26];
    Trie() {
        end = false;
        memset(next,0,sizeof(next));
    }
  
    void insert(string word) {
        Trie* node = this;
        for(char c:word)
        {
            if(node->next[c-'a']==NULL)
            {
                node->next[c-'a'] = new Trie();
            }
            node = node->next[c-'a'];
        }
        node->end = true;
    }
  
    bool search(string word) {
        Trie* node = this;
        for(char c:word)
        {
            if(node->next[c-'a']==NULL)
            return false;
            node = node->next[c-'a'];
        }
        if(node->end)
        return true;
        else return false;
    }
  
    bool startsWith(string prefix) {
        Trie* node = this;
        for(char c:prefix)
        {
            if(node->next[c-'a']==NULL)
            return false;
            node = node->next[c-'a'];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

55.全排列

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**示例 1：**

<pre><strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>

**示例 2：**

<pre><strong>输入：</strong>nums = [0,1]
<strong>输出：</strong>[[0,1],[1,0]]
</pre>

**示例 3：**

<pre><strong>输入：</strong>nums = [1]
<strong>输出：</strong>[[1]]</pre>

思路：用dfs遍历数组nums，然后用vis标记每个元素是否已经被选择过，从而确保在一条路径中，没有重复的元素；然后回溯的时候需要还原vis和tmp

```
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> vis;
    vector<vector<int>> permute(vector<int>& nums) {
        if(nums.size()==0) return ans;
        for(int i=0;i<nums.size();i++)
        vis.push_back(0);
        vector<int> tmp;
        dfs(nums,nums.size(),tmp);
        return ans;
    }
    void dfs(vector<int> nums,int left,vector<int> tmp)
    {
        if(left==0)
        {
            ans.push_back(tmp);
            return;
        }
        for(int i=0;i<nums.size();i++)
        {
            if(!vis[i])
            {
                vis[i]=1;
                tmp.push_back(nums[i]);
                dfs(nums,left-1,tmp);
                tmp.pop_back();
                vis[i]=0;
            }
        }
    }
};
```

56.子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

<pre><strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</pre>

**示例 2：**

<pre><strong>输入：</strong>nums = [0]
<strong>输出：</strong>[[],[0]]</pre>

思路：类似于上一题的全排列，但是在这里可以不使用vis数组标记是否选择过该元素，因为往下递归，会选择后面的元素。

```
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        if(n==0) return ans;
        vector<int> tmp;
        dfs(nums,n,0,tmp);
        ans.push_back(nums);
        return ans;
    }
    void dfs(vector<int> nums,int len,int index,vector<int> tmp)
    {
        if(len==0){
            return;
        }
        for(int i=index;i<nums.size();i++)
        {
            tmp.push_back(nums[i]);
            dfs(nums,len-1,i+1,tmp);
            tmp.pop_back();
        }
        ans.push_back(tmp);
    }
};
```

57.电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

**示例 1：**

<pre><strong>输入：</strong>digits = "23"
<strong>输出：</strong>["ad","ae","af","bd","be","bf","cd","ce","cf"]
</pre>

**示例 2：**

<pre><strong>输入：</strong>digits = ""
<strong>输出：</strong>[]
</pre>

**示例 3：**

<pre><strong>输入：</strong>digits = "2"
<strong>输出：</strong>["a","b","c"]</pre>

思路：首先确定每个数字代表的几个字母，然后依次向下遍历，回溯时，将已经插入tmp的字母弹出

```
class Solution {
public:
    vector<char> dic[10];
    vector<string> ans;
    vector<string> letterCombinations(string digits) {
        if(digits.size()==0) return {};
        int ind = 0;
        for(int i=2;i<10;i++)
        {
            dic[i].push_back(char('a' + (ind++)));
            dic[i].push_back(char('a' + (ind++)));
            dic[i].push_back(char('a' + (ind++)));
            if(i==7 || i==9)
            dic[i].push_back(char('a' + (ind++)));
        }
        string tmp;
        dfs(digits,0,tmp);
        return ans;
    }
    void dfs(string digits,int len,string tmp)
    {
        if(len == digits.size()){
            ans.push_back(tmp);
            return;
        }
        int p = digits.at(len) - '0';
        for(auto i : dic[p])
        {
            tmp.push_back(i);
            dfs(digits,len+1,tmp);
            tmp.pop_back();
        }
    }
};
```

58.组合总和

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

**示例 1：**

<pre><strong>输入：</strong>candidates = [2,3,6,7], target = 7
<strong>输出：</strong>[[2,2,3],[7]]
<strong>解释：</strong>
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。</pre>

**示例 2：**

<pre><strong>输入: </strong>candidates = [2,3,5], target = 8
<strong>输出: </strong>[[2,2,2,2],[2,3,3],[3,5]]</pre>

**示例 3：**

<pre><strong>输入: </strong>candidates = [2], target = 1
<strong>输出: </strong>[]</pre>

思路：在dfs之前先排序，方便后续处理。然后防止出现重复候选，在向下遍历的时候需要修改遍历的索引

```
class Solution {
public:
    vector<vector<int>> ans;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        dfs(candidates,target,0,{});
        return ans;
    }
    void dfs(vector<int> candidates,int target,int index,vector<int> tmp)
    {
        if(target < 0)
        {
            return;
        }
        if(target == 0)
        {
            ans.push_back(tmp);
        }
        for(int i=index;i<candidates.size();i++)
        {
            if(candidates[i] <= target)
            {
                tmp.push_back(candidates[i]);
                target-=candidates[i];
                dfs(candidates,target,i,tmp);
                target+=candidates[i];
                tmp.pop_back();
            }
        }
    }
};
```

59.括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且**有效的**括号组合。

**示例 1：**

<pre><strong>输入：</strong>n = 3
<strong>输出：</strong>["((()))","(()())","(())()","()(())","()()()"]
</pre>

**示例 2：**

<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>["()"]</pre>

思路：观察样例发现，左括号随时可以插入，但是右括号有限制：目前右括号数量必须小于左括号，所以在dfs中，不断判断是否满足限制条件。

```
class Solution {
public:
    vector<string> ans;
    vector<string> generateParenthesis(int n) {
        if(n==0) return {};
        dfs(n,0,0,{});
        return ans;
    }
    void dfs(int n,int left,int right,string tmp)
    {
        if(left==n && right==n){
            ans.push_back(tmp);
            return;
        }
        if(left < n){
            tmp.push_back('(');
            dfs(n,left+1,right,tmp);
            tmp.pop_back();
        }
        if(right < n && right < left)
        {
            tmp.push_back(')');
            dfs(n,left,right+1,tmp);
            tmp.pop_back();
        }
    }
};
```

60.单词搜索

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例 1：**

<pre><strong>输入：</strong>board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "ABCCED"
<strong>输出：</strong>true
</pre>

**示例 2：**

<pre><strong>输入：</strong>board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "SEE"
<strong>输出：</strong>true
</pre>

**示例 3：**

<pre><strong>输入：</strong>board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "ABCB"
<strong>输出：</strong>false</pre>

思路：对矩阵中每个点进行dfs，判断是否能和word的字母对应，然后需要使用vis数组标记，防止重复遍历同一元素，回溯时需要回溯vis

```
class Solution {
public:
    int mx[4] = {0,0,1,-1},my[4] = {1,-1,0,0};
    bool exist(vector<vector<char>>& board, string word) {
        int h = board.size(), w = board[0].size();
        vector<vector<int>> vis(h,vector<int>(w));
        for(int i=0;i<board.size();i++)
        {
            for(int j=0;j<board[0].size();j++)
            {
                if(dfs(board,word,i,j,0,vis)) return true;
            }
        }
        return false;
    }
    bool dfs(vector<vector<char>>& board, string word, int x,int y,int len,vector<vector<int>>& vis)
    {
        if(board[x][y] != word[len]) return false;
        if(len == word.size()-1) return true;
        vis[x][y] = true;
        bool res = false;
        for(int i=0;i<4;i++)
        {
            int cx = x + mx[i], cy = y + my[i];
            if(cx < 0 || cy < 0 || cx >= board.size() || cy >= board[0].size()) continue;
            if(!vis[cx][cy])
            {
                bool tmp = dfs(board,word,cx,cy,len+1,vis);
                if(tmp){
                    res = tmp;
                    break;
                }
            }
        }
        vis[x][y] = false;
        return res;
    }
};
```
