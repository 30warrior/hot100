61.分割回文串

给你一个字符串 `s`，请你将 `s` 分割成一些 子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**示例 1：**

<pre><strong>输入：</strong>s = "aab"
<strong>输出：</strong>[["a","a","b"],["aa","b"]]
</pre>

**示例 2：**

<pre><strong>输入：</strong>s = "a"
<strong>输出：</strong>[["a"]]</pre>

思路：首先写一个函数判断字符串s的子串是否为回文串，然后再进行dfs，判断可以往下递归的条件为从index到i的子串为回文串。

```
class Solution {
public:
    vector<vector<string>> ans;
    vector<vector<string>> partition(string s) {
        if(s.size()==0) return {};
        dfs(s,0,{});
        return ans;
    }
    void dfs(string s,int index,vector<string> tmp)
    {
        if(index == s.size()){
            ans.push_back(tmp);
            return;
        }
        for(int i=index;i<s.size();i++)
        {
            if(huiwen(s,index,i)){
                tmp.push_back(s.substr(index,i-index+1));
                dfs(s,i+1,tmp);
                tmp.pop_back();
            }
        }
    }
    bool huiwen(string s,int index,int i)
    {
        while(index < i)
        {
            if(s[index++] == s[i--])
            continue;
            else return false;
        }
        return true;
    }
};
```

62.N皇后

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例 1：**

<pre><strong>输入：</strong>n = 4
<strong>输出：</strong>[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
</pre>

**示例 2：**

<pre><strong>输入：</strong>n = 1
<strong>输出：</strong>[["Q"]]</pre>

思路：用三个数组col、d和fd分别表示每一列、每条对角线的分布情况，然后在dfs中，逐行进行递归，同时判断该行的每一列和对角线是否能放皇后，最后回溯时需要回溯三个数组。

```
class Solution {
public:
    vector<int> d,fd,col;
    vector<vector<string>> ans;
    vector<vector<string>> solveNQueens(int n) {
        for(int i=0;i<2*n;i++)
        {
            d.push_back(0);
            fd.push_back(0);
        }
        for(int i=0;i<n;i++)
            col.push_back(0);
        //表示两条对角线
        dfs(n,0,{});
        return ans;
    }
    void dfs(int n,int cur,vector<string> tmp)
    {
        if(cur == n)
        {
            ans.push_back(tmp);
            return;
        }
        for(int i=0;i<n;i++)
        {
            if(col[i] == 0){
                if(d[cur-i+n-1]==0 && fd[cur+i]==0){
                    col[i]=1,d[cur-i+n-1]=1,fd[i+cur]=1;
                    tmp.push_back(work(i,n));
                    dfs(n,cur+1,tmp);
                    col[i]=0,d[cur-i+n-1]=0,fd[i+cur]=0;
                    tmp.pop_back();
                }
            }
        }
    }
    string work(int x,int n)
    {
        string tmp;
        for(int i=0;i<x;i++) tmp.push_back('.');
        tmp.push_back('Q');
        for(int i=x+1;i<n;i++) tmp.push_back('.');
        return tmp;
    }
};
```

63.搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例 1:**

<pre><strong>输入:</strong> nums = [1,3,5,6], target = 5
<strong>输出:</strong> 2
</pre>

**示例 2:**

<pre><strong>输入:</strong> nums = [1,3,5,6], target = 2
<strong>输出:</strong> 1
</pre>

**示例 3:**

<pre><strong>输入:</strong> nums = [1,3,5,6], target = 7
<strong>输出:</strong> 4</pre>

思路：二分查找，同时需要注意left和right的变化，因为需要确保在while停止之前，left和right的值会变化，同时让left=mid+1，可以确保如果没有target时最后循环停止的时候left就是应该插入的位置

```
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0,right = nums.size()-1;
        while(left <= right)
        {
            int mid = (left + right) / 2;
            cout<<left<<" "<<right<<" "<<nums[mid]<<endl;
            if(target > nums[mid]){
                left = mid+1;
            }
            else if(target < nums[mid]){
                right = mid-1;
            }
            else if(target == nums[mid])
            return mid;
        }
        return left;
    }
};
```

64.搜索二维矩阵

给你一个满足下述两条属性的 `m x n` 整数矩阵：

* 每行中的整数从左到右按非严格递增顺序排列。
* 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

**示例 1：**

<pre><strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
<strong>输出：</strong>true
</pre>

**示例 2：**

<pre><strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
<strong>输出：</strong>false</pre>

思路：和63相同，但是需要将mid转化为二维矩阵的两个维度

```
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size(), m = matrix[0].size();
        int left = 0,right = m*n-1;
        while(left <= right)
        {
            int mid = (left+right)/2;
            int p = matrix[mid/m][mid%m];
            if(p == target)
            return true;
            else if(p < target)
            left = mid+1;
            else right = mid-1;
        }
        return false;
    }
};
```

65.在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

<pre><strong>输入：</strong><code>nums = [5,7,7,8,8,10], target = 8</code>
<strong>输出：</strong>[3,4]</pre>

**示例 2：**

<pre><strong>输入：</strong><code>nums = [5,7,7,8,8,10], target = 6</code>
<strong>输出：</strong>[-1,-1]</pre>

**示例 3：**

<pre><strong>输入：</strong>nums = [], target = 0
<strong>输出：</strong>[-1,-1]</pre>

思路：进行两次二分查找，第一次查找该元素的第一个位置，第二次查找最后的位置，然后在查找过程中，当找到这个元素时不停止循环，而是继续向左/右搜索，确保能找到最左/右的位置。

```
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int first=-1,second=-1;
        int left = 0,n = nums.size()-1,right = n;
        while(left <= right)
        {
            int mid = left + (right - left)/2, p = nums[mid];
            if(p == target)
            {
                first = mid;
                right = mid-1;
            }
            else if(p < target)
            left = mid+1;
            else right = mid-1;
        }
        left=0,right=n;
        while(left <= right)
        {
            int mid = left + (right - left)/2, p = nums[mid];
            if(p == target)
            {
                second = mid;
                left = mid+1;
            }
            else if(p < target)
            left = mid+1;
            else right = mid-1;
        }
        vector<int> ans;
        ans.push_back(first);
        ans.push_back(second);
        return ans;
    }
};
```

66.搜索旋转排序数组

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了  **向左旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 下标 `3` 上向左旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

<pre><strong>输入：</strong><code>nums = [4,5,6,7,0,1,2], target = 0</code>
<strong>输出：</strong>4
</pre>

**示例 2：**

<pre><strong>输入：</strong><code>nums = [4,5,6,7,0,1,2], target = 3</code>
<strong>输出：</strong>-1</pre>

**示例 3：**

<pre><strong>输入：</strong><code>nums = [1], target = 0</code>
<strong>输出：</strong>-1</pre>

思路：用二分的思想，肯定可以将数组分为一个有序，一个不一定有序，然后再在有序数组中进行二分查找，如果target小于nums[mid]，说明在数组左侧，反之在数组右侧。

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        if(n==0) return -1;
        int l=0, r=n-1;
        while(l<=r)
        {
            int mid = l + (r-l) / 2;
            if(nums[mid] == target) return mid;
            if(nums[l] <= nums[mid]){
                if(nums[l] <= target && target < nums[mid]){
                    r = mid-1;
                }
                else l = mid+1;
            }
            else{
                if(nums[mid] < target && target <= nums[r])
                l = mid+1;
                else r = mid-1;
            }
        }
        return -1;
    }
};
```

67.寻找旋转排序数组中的最小值

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：* 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`

* 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

<pre><strong>输入：</strong>nums = [3,4,5,1,2]
<strong>输出：</strong>1

**示例 2：**

<pre><strong>输入：</strong>nums = [4,5,6,7,0,1,2]
<strong>输出：</strong>0
</pre>

**示例 3：**

<pre><strong>输入：</strong>nums = [11,13,15,17]
<strong>输出：</strong>11</pre>

思路：和上一道类似，进行二分，此时一半是升序的，另一半不一定，此时选择升序的那一半的最左端元素为最小元素

```
class Solution {
public:
    int findMin(vector<int>& nums) {
        int l = 0,r = nums.size()-1,ans=1e4;
        while(l<=r)
        {
            int mid = l + (r-l)/2;
            if(nums[mid] >= nums[l]){
                ans = min(ans,nums[l]);
                l = mid+1;
            }
            else {
                ans = min(ans,nums[mid]);
                r = mid-1;
            }
        }
        return ans;
    }
};
```

68.有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

 **输入：** **s = "()"**

 **输出：** **true**

**示例 2：**

 **输入：** **s = "()[]{}"**

 **输出：** **true**

**示例 3：**

 **输入：** **s = "(]"**

 **输出：** **false**

**示例 4：**

 **输入：** **s = "([])"**

 **输出：** **true**

**示例 5：**

 **输入：** **s = "([)]"**

 **输出：** **false**

思路：用一个栈存储左括号，然后依次遍历字符串，当遇到右括号时，判断是否此时栈顶能与之匹配，如果匹配则弹出栈顶元素，否则说明字符串不有效。

```
class Solution {
public:
    bool isValid(string s) {
        int len = s.size();
        if(!len) return true;
        if(len % 2 == 1) return false;
        stack<char> q;
        for(auto i : s){
            if(i=='(' || i=='[' || i=='{')
            q.push(i);
            else if(q.empty()) return false;
            else if((i==')' || i==']' || i=='}')) 
            {   
                cout<<i<<endl;
                if((i==')' && q.top()=='(') || (i==']' && q.top()=='[') || (i=='}' && q.top()=='{'))
                q.pop();
                else q.push(i);
            }
            // else q.push(i);
        }
        if(q.empty()) return true;
        else return false;
    }
};
```

69.最小栈

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

* `MinStack()` 初始化堆栈对象。
* `void push(int val)` 将元素val推入堆栈。
* `void pop()` 删除堆栈顶部的元素。
* `int top()` 获取堆栈顶部的元素。
* `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

<pre><strong>输入：</strong>
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

<strong>输出：</strong>
[null,null,null,null,-3,null,0,-2]</pre>

思路：因为需要在常数时间内找到最小元素，所以需要用一个辅助栈存储当前最小元素，然后当插入元素时，判断辅助栈中插入的是当前元素还是辅助栈顶元素；当弹出元素时也直接弹出辅助栈栈顶元素。因为当插入的元素不是目前最小的元素时，辅助栈栈顶插入的元素仍然是当前最小的元素，且当栈中最小元素被弹出的时候，辅助栈中也同时弹出这个元素的最后一个。

```
class MinStack {
public:
    stack<int> v;
    stack<int> minv;
    MinStack() {
        minv.push(INT_MAX);
    }
  
    void push(int val) {
        v.push(val);
        minv.push(min(val,minv.top()));
    }
  
    void pop() {
        minv.pop();
        v.pop();
    }
  
    int top() {
        return v.top();
    }
  
    int getMin() {
        // if(minv.top() != INT_MAX)
        return minv.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

70.字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

测试用例保证输出的长度不会超过 `10^5`。

**示例 1：**

<pre><strong>输入：</strong>s = "3[a]2[bc]"
<strong>输出：</strong>"aaabcbc"
</pre>

**示例 2：**

<pre><strong>输入：</strong>s = "3[a2[c]]"
<strong>输出：</strong>"accaccacc"
</pre>

**示例 3：**

<pre><strong>输入：</strong>s = "2[abc]3[cd]ef"
<strong>输出：</strong>"abcabccdcdcdef"
</pre>

**示例 4：**

<pre><strong>输入：</strong>s = "abc3[cd]xyz"
<strong>输出：</strong>"abccdcdcdxyz"</pre>

思路：用一个栈存放字母，左括号以及数字，当匹配到右括号时，先还原括号内字符串，然后还原数字，将其解码后重新放入栈内，这是处理嵌套的关键，最后循环结束后再将栈内元素转换为字符串并翻转。

```
class Solution {
public:
    string decodeString(string s) {
        stack<char> st;
        string ans;
        for(auto i : s){
            if(i != ']')
            st.push(i);
            else{
                string tmpn,tmps;
                while(st.top() != '[')
                {
                    tmps += st.top();
                    st.pop();
                }
                st.pop(); // 弹出[
                reverse(tmps.begin(),tmps.end());
                while(st.size())
                {
                    if(st.top() <= '9' && st.top() >= '0'){
                        tmpn += st.top();
                        st.pop();
                    }
                    else break;
                }
                reverse(tmpn.begin(),tmpn.end());
                int n = stoi(tmpn);
                for(int j=0;j<n;j++)
                {
                    for(auto k : tmps)
                    st.push(k);
                }
            }
        }
        while(st.size())
        {
            ans += st.top();
            st.pop();
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
```
