21.搜索二维矩阵 Ⅱ

编写一个高效的算法来搜索 `<em>m</em> x <em>n</em>` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

* 每行的元素从左到右升序排列。
* 每列的元素从上到下升序排列。

**示例 1：**

<pre><b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
<b>输出：</b>true
</pre>

**示例 2：**

<pre><b>输入：</b>matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
<b>输出：</b>false</pre>

思路：一开始对每一行使用二分查找，但是时间复杂度为O(mlogn)，采用z形搜索，当matrix[i][j]<target时，i+1；当matrix[i][j]>target时，j-1。每次比较可以排除一行/列，时间复杂度为O(m+n)

```
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int x=0,y=n-1;
        while(x<m && y>=0){
            int tmp = matrix[x][y];
            if(tmp==target)
            return 1;
            else if(tmp < target)
            x++;
            else y--;
        }
        return 0;
    }
};
```

22.相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

题目数据 **保证** 整个链式结构中不存在环。

 **注意** ，函数返回结果后，链表必须 **保持其原始结构** 。

**自定义评测：**

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

* `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
* `listA` - 第一个链表
* `listB` - 第二个链表
* `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
* `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

**示例 1：**

<pre><strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
<strong>输出：</strong>Intersected at '8'
<strong>解释：</strong>相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中<font size="1">第三个</font>节点，B 中第四个节点) 在内存中指向相同的位置。
</pre>

**示例 2：**

<pre><strong>输入：</strong>intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
<strong>输出：</strong>Intersected at '2'
<strong>解释：</strong>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
</pre>

**示例 3：**

<pre><strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
<strong>输出：</strong>No intersection
<strong>解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。</pre>

思路：使用哈希表记录A的每一个节点，然后遍历B的每个节点，并在哈希表中进行匹配

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode*> s;
        while(headA!=NULL)
        {
            s.insert(headA);
            headA = headA->next;
        }
        while(headB!=NULL)
        {
            if(s.find(headB)!=s.end())
            return headB;
            headB = headB->next;
        }
        return NULL;
    }
};
```

23.反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

<pre><strong>输入：</strong>head = [1,2,3,4,5]
<strong>输出：</strong>[5,4,3,2,1]
</pre>

**示例 2：**

<pre><strong>输入：</strong>head = [1,2]
<strong>输出：</strong>[2,1]
</pre>

**示例 3：**

<pre><strong>输入：</strong>head = []
<strong>输出：</strong>[]</pre>

思路：用一个指针指向当前节点p需要指向的节点，然后不断让p后移。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* p = head;
        ListNode* oldnext = nullptr;
        while(p!=nullptr)
        {
            ListNode* tmp = p->next;
            p->next = oldnext;
            oldnext = p;
            p = tmp;
        }
        return oldnext;
    }
};
```

24.回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

<pre><strong>输入：</strong>head = [1,2,2,1]
<strong>输出：</strong>true
</pre>

**示例 2：**

<pre><strong>输入：</strong>head = [1,2]
<strong>输出：</strong>false</pre>

思路：用一个栈存储链表中的每一个元素，然后重新遍历链表，依次和栈顶元素进行比较。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        stack<int> s;
        ListNode *p = head;
        while(p!=nullptr)
        {
            s.push(p->val);
            p = p->next;
        }
        p = head;
        while(p!=nullptr){
            if(p->val != s.top())
            return false;
            s.pop();
            p = p->next;
        }
        return true;
    }
};
```

25.环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 **注意：`pos` 不作为参数进行传递 ** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false`

**示例 1：**

<pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1
<strong>输出：</strong>true
<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点</pre>

**示例 2：**

<pre><strong>输入：</strong>head = [1,2], pos = 0
<strong>输出：</strong>true
<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。
</pre>

**示例 3：**

<pre><strong>输入：</strong>head = [1], pos = -1
<strong>输出：</strong>false
<strong>解释：</strong>链表中没有环。</pre>

思路：用哈希表存检查每个节点是否出现过。或者快慢指针，让快指针走的比慢指针快两倍，然后检查是否出现快慢指针相等的情况

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head == NULL || head->next == NULL)
        return false;
        ListNode *slow = head;
        ListNode *fast = head->next;
        while(slow!=fast)
        {
            if(fast==NULL || fast->next==NULL)
            {
                return false;
            }
            slow = slow->next;
            fast = fast->next->next;
        }
        return true;
    }
};
```

26. 环形链表Ⅱ

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（ **索引从 0 开始** ）。如果 `pos` 是 `-1`，则在该链表中没有环。 **注意：`pos` 不作为参数进行传递** ，仅仅是为了标识链表的实际情况。

**不允许修改 **链表。

**示例 1：**

<pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1
<strong>输出：</strong>返回索引为 1 的链表节点
<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。
</pre>

**示例 2：**

<pre><strong>输入：</strong>head = [1,2], pos = 0
<strong>输出：</strong>返回索引为 0 的链表节点
<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。
</pre>

**示例 3：**

<pre><strong>输入：</strong>head = [1], pos = -1
<strong>输出：</strong>返回 null
<strong>解释：</strong>链表中没有环。</pre>

思路：和上一道题类似，但是需要找到环的入口，首先判断是否存在环，然后寻找环的入口（因为快慢指针相遇处不一定是入口）。假设链表头到入口距离为a，入口到两指针相遇处距离为b，两指针相遇处到入口距离为c（环剩余部分长度）。慢指针走了a+b，快指针则走了a+b+k(b+c)=2(a+b)，所以a=(k-1)(b+c)+c，所以如果慢指针再走a步，则总距离为2a+b=k(b+c)+a，刚好到入口。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        // if(head == nullptr || head->next == nullptr)
        // return nullptr;
        ListNode *slow = head;
        ListNode *fast = head;
        while(1)
        {
            if(fast==nullptr || fast->next==nullptr )
            return nullptr;
            fast = fast->next->next;
            slow = slow->next;
            if(fast==slow)
            break;
        }
        ListNode* ptr = head;
        while(ptr!=slow)
        {
            ptr = ptr->next;
            slow = slow->next;
        }
        return ptr;
    }
};
```

27.合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1：**

<pre><strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]
<strong>输出：</strong>[1,1,2,3,4,4]
</pre>

**示例 2：**

<pre><strong>输入：</strong>l1 = [], l2 = []
<strong>输出：</strong>[]
</pre>

**示例 3：**

<pre><strong>输入：</strong>l1 = [], l2 = [0]
<strong>输出：</strong>[0]</pre>

思路：增加一个头指针，然后按顺序将链表中的元素接到头指针，最后检查哪个链表有剩余，将剩余部分接到末尾。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* p = new ListNode();
        ListNode* tmp = p;
        while(list1!=nullptr && list2!=nullptr)
        {
            if(list1->val <= list2->val)
            {
                p->next = list1;
                list1 = list1->next;
            }
            else{
                p->next = list2;
                list2 = list2->next;
            }
            p = p->next;
        }
        p->next = list1==nullptr ? list2 : list1;
        return tmp->next;
    }
};
```

28.两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

<pre><strong>输入：</strong>l1 = [2,4,3], l2 = [5,6,4]
<strong>输出：</strong>[7,0,8]
<strong>解释：</strong>342 + 465 = 807.
</pre>

**示例 2：**

<pre><strong>输入：</strong>l1 = [0], l2 = [0]
<strong>输出：</strong>[0]
</pre>

**示例 3：**

<pre><strong>输入：</strong>l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
<strong>输出：</strong>[8,9,9,9,0,0,0,1]</pre>

思路：模拟加法

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode();
        ListNode* curr = dummy;
        int carry = 0;
        while(l1 || l2 || carry) {
            int a = l1 ? l1->val : 0;
            int b = l2 ? l2->val : 0;
            int sum = a + b + carry;
            carry = sum >= 10 ? 1 : 0;
            curr->next = new ListNode(sum % 10);
            curr = curr->next;
            if(l1) l1 = l1->next;
            if(l2) l2 = l2->next;
        }
        return dummy->next;
    }
};
```

29.删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

<pre><strong>输入：</strong>head = [1,2,3,4,5], n = 2
<strong>输出：</strong>[1,2,3,5]
</pre>

**示例 2：**

<pre><strong>输入：</strong>head = [1], n = 1
<strong>输出：</strong>[]
</pre>

**示例 3：**

<pre><strong>输入：</strong>head = [1,2], n = 1
<strong>输出：</strong>[1]</pre>

思路：先遍历链表，找到要删除的结点是正数第m个，然后遍历到对应位置将其删除。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* tmp = head;
        int len = 0;
        while(tmp!=nullptr){
            len++;
            tmp = tmp->next;
        }
        if(n==len) return head->next;
        len -= n;
        tmp = head;
        for(int i=0;i<len-1;i++)
        tmp = tmp->next;
        tmp->next = tmp->next->next;
        return head;
    }
};
```

30.两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

<pre><strong>输入：</strong>head = [1,2,3,4]
<strong>输出：</strong>[2,1,4,3]
</pre>

**示例 2：**

<pre><strong>输入：</strong>head = []
<strong>输出：</strong>[]
</pre>

**示例 3：**

<pre><strong>输入：</strong>head = [1]
<strong>输出：</strong>[1]</pre>

思路：增加一个头指针，作为翻转的两个节点的头部，相当于一次循环需要操作三个节点。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==nullptr) return nullptr;
        if(head->next==nullptr) return head;
        ListNode* p = new ListNode(0);
        p->next = head;
        ListNode* np = p;
        while(p->next!=nullptr && p->next->next!=nullptr)
        {
            ListNode* tmp1 = p->next;
            ListNode* tmp2 = tmp1->next;
            p->next = tmp2;
            tmp1->next = tmp2->next;
            tmp2->next = tmp1;
            p = tmp1;
        }
        return np->next;
    }
};
```
