1.两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 和为目标值 `target`的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1：**

<pre><strong>输入：</strong>nums = [2,7,11,15], target = 9
<strong>输出：</strong>[0,1]
<strong>解释：</strong>因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
</pre>

**示例 2：**

<pre><strong>输入：</strong>nums = [3,2,4], target = 6
<strong>输出：</strong>[1,2]
</pre>

**示例 3：**

<pre><strong>输入：</strong>nums = [3,3], target = 6
<strong>输出：</strong>[0,1]</pre>

思路：如果用暴力枚举，需要O(n*n)，时间复杂度过高。所以这里用哈希表存储元素的值以及索引，依次遍历数组元素，如果此时在哈希表中可以找到能匹配上的元素，就直接返回这两个元素的索引，否则将这个元素放入哈希表

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> mm;
        vector<int> ans;
        for(int i=0;i<nums.size();i++){
            int left = target - nums[i];
            if(mm.find(left) != mm.end())
            {
                ans.push_back(mm[left]);
                ans.push_back(i);
                return ans;
            }
            if(mm.find(nums[i]) == mm.end()){
                mm.insert(pair(nums[i],i));
            }
        }
        return ans;
    }
};
```

2.字母异位词

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

**示例 1:**

<pre><strong>输入:</strong> strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
<strong>输出:  </strong>[["bat"],["nat","tan"],["ate","eat","tea"]]
</pre>

**解释：**

* 在 strs 中没有字符串可以通过重新排列来形成 `"bat"`。
* 字符串 `"nat"` 和 `"tan"` 是字母异位词，因为它们可以重新排列以形成彼此。
* 字符串 `"ate"` ，`"eat"` 和 `"tea"` 是字母异位词，因为它们可以重新排列以形成彼此。

**示例 2:**

<pre><strong>输入:</strong> strs = [""]
<strong>输出:  </strong>[[""]]
</pre>

**示例 3:**

<pre><strong>输入: </strong>strs = ["a"]
<strong>输出:  </strong>[["a"]]
</pre>

思路：对每个字符串进行内部排序，然后作为哈希表的键，然后此时的异位词会变为相同的词，将他们还原并放入哈希表，此时这个键所含的字符串组会构成一个向量，所以直接将各个键的向量输出

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;
        for (string& str: strs) {
            string key = str;
            sort(key.begin(), key.end());
            mp[key].emplace_back(str);
        }
        vector<vector<string>> ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            ans.emplace_back(it->second);
        }
        return ans;

    }
};
```

3.最长连续子序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

<pre><strong>输入：</strong>nums = [100,4,200,1,3,2]
<strong>输出：</strong>4
<strong>解释：</strong>最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</pre>

**示例 2：**

<pre><strong>输入：</strong>nums = [0,3,7,2,5,8,4,6,0,1]
<strong>输出：</strong>9
</pre>

**示例 3：**

<pre><strong>输入：</strong>nums = [1,0,1,2]
<b>输出：</b>3</pre>

思路：首先用哈希表存储每个数，然后一直遍历哈希表，当找到连续子序列中最小的数字时，顺序查找以它为开头的序列，记录长度，并更新当前最长连续子序列的长度。

```
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> mm;
        int ans = 0;
        for(auto i : nums)
        {
            mm.insert(i);
        }
        for(int n : mm)
        {
            if(mm.find(n-1)==mm.end())
            {
                int cnum=n;
                int clen=1;
                while(mm.find(cnum+1)!=mm.end())
                {
                    cnum ++;
                    clen++;
                }
                ans=max(ans,clen);
            }
        }
        return ans;
    }
};
```

4.移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

<pre><strong>输入:</strong> nums = <code>[0,1,0,3,12]</code>
<strong>输出:</strong> <code>[1,3,12,0,0]</code>
</pre>

**示例 2:**

<pre><strong>输入:</strong> nums = <code>[0]</code>
<strong>输出:</strong> <code>[0]</code></pre>

思路：用index记录第一个非零元素需要移动的位置，然后每次找到非零元素就与其交换，起初想用类似冒泡排序的做法，但是时间复杂度更高，而且部分细节需要处理

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int l = nums.size(),index=0;
        for(int i=0;i<l;i++)
        {
            if(nums[i]!=0)
            {
                swap(nums[i],nums[index]);
                index++;
            }
        }
    }
};
```

5.盛最多水的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**示例 1：**

<pre><strong>输入：</strong>[1,8,6,2,5,4,8,3,7]
<strong>输出：</strong>49</pre>

思路：用双指针分别存储当前容器的左右端点，并计算当前容器所能存储的水，并更新最大值。同时根据容器左右高度，移动指针。

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int ans=0,left=0,right=height.size()-1;
        while(left!=right)
        {
            int a=height[left],b=height[right];
            int cur = abs(right-left) * min(a,b);
            ans = max(ans,cur);
            if(a < b)
            left++;
            else right--;
        }
        return ans;
    }
};
```

6.三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

 **注意：** 答案中不可以包含重复的三元组。

**示例 1：**

<pre><strong>输入：</strong>nums = [-1,0,1,2,-1,-4]
<strong>输出：</strong>[[-1,-1,2],[-1,0,1]]
<strong>解释：</strong>
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
</pre>

**示例 2：**

<pre><strong>输入：</strong>nums = [0,1,1]
<strong>输出：</strong>[]
<strong>解释：</strong>唯一可能的三元组和不为 0 。</pre>

思路：首先对数组进行排序，然后依次选择前两个数，并从后往前寻找第三个数，不断减小它的值。**因为要保证答案中每个三元组都不同，所以需要确保在选择前两个数的时候不会和上一个数相同**

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int len = nums.size();
        sort(nums.begin(),nums.end());
        vector<vector<int>> ans;
        for(int i=0;i<len;i++)
        {
            if(i>0 && nums[i]==nums[i-1])
            {
                continue;
            }
            int k=len-1,sum = -nums[i];
            for(int j=i+1;j<len;j++)
            {
                if(j>i+1 && nums[j]==nums[j-1])
                continue;
                while(j<k && nums[j] + nums[k] != sum)
                {
                    --k;
                }
                if(j==k)
                break;
                if(nums[j] + nums[k] == sum)
                {
                    ans.push_back({nums[i],nums[j],nums[k]});
                }
            }
        }
        return ans;
    }
};
```

7.接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水

**示例 1：**

<pre><strong>输入：</strong>height = [0,1,0,2,1,0,1,3,2,1,2,1]
<strong>输出：</strong>6</pre>

**示例 2：**

<pre><strong>输入：</strong>height = [4,2,0,3,2,5]
<strong>输出：</strong>9</pre>

思路：下标为i的位置所能接的雨水为此时左/右最大高度的最小值 - 当前位置的高度，所以选择双指针不断循环更新最大高度

```
class Solution {
public:
    int trap(vector<int>& height) {
        int left = 0, right = height.size()-1, ans = 0;
        int lefth = height[0], righth = height[right];
        while(left!=right)
        {
            if(lefth < righth)
            {
                ans += min(lefth,righth) - height[left];
                left++;
                lefth = max(lefth,height[left]);
            }
            else{
                ans += min(lefth,righth) - height[right];
                right--;
                righth = max(righth,height[right]);
            }
        }
        return ans;
    }
};
```

8.无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的**最长子串**的长度 cabcbb"

**示例 2:**

<pre><strong>输入: </strong>s = "bbbbb"
<strong>输出: </strong>1
<strong>解释: </strong>因为无重复字符的最长子串是 <code>"b"</code>，所以其长度为 1。
</pre>

**示例 3:**

<pre><strong>输入: </strong>s = "pwwkew"
<strong>输出: </strong>3
<strong>解释: </strong>因为无重复字符的最长子串是 <code>"wke"</code>，所以其长度为 3。
     请注意，你的答案必须是 <strong>子串 </strong>的长度，<code>"pwke"</code> 是一个<em>子序列，</em>不是子串</pre>

思路：使用一个set存放当前窗口内所含的字母，每次窗口右端+1，判断是否这个新字母已出现在窗口中，如果不存在，则直接窗口长度+1，否则不断删除窗口左端的字母直到满足条件。

```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        set<char> a;
        int l = s.size(),ans=0,left=0;
        for(int left=0,right=0;right<l;right++)
        {
            char ch = s[right];
            while(a.contains(ch))
            {
                a.erase(s[left]);
                left++;
            }
            a.insert(s[right]);
            ans = max(right-left+1,ans);
        }
        return ans;
    }
};
```



9.找到字符串中所有异位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词 **的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**示例 1:**

<pre><strong>输入: </strong>s = "cbaebabacd", p = "abc"
<strong>输出: </strong>[0,6]
<strong>解释:</strong>
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
</pre>

** 示例 2:**

<pre><strong>输入: </strong>s = "abab", p = "ab"
<strong>输出: </strong>[0,1,2]
<strong>解释:</strong>
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。</pre>

思路：最开始的时候选择了和前面类似的寻找异位词的做法（排序），但是时间复杂度太高了，所以只能用滑动窗口。用两个长度为26的数组分别记录s和p所含的各个字母的数量，然后每次移动窗口，都更新s对应的数组，并将两个数组进行比对，如果数组相同说明此时子串能和p匹配。

```
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int sl = s.size(), pl = p.size();
        if(sl < pl) return {};
        vector<int> ss(26);
        vector<int> pp(26);
        vector<int> ans;
        for(int i=0;i<pl;i++)
        {
            ss[s[i] - 'a']++;
            pp[p[i] - 'a']++;
        }
        if(ss==pp) ans.push_back(0);
        for(int i=0;i<sl-pl;i++)
        {
            // cout<<i<<" ";
            ss[s[i]-'a']--;
            ss[s[i+pl]-'a']++;
            if(ss==pp) ans.push_back(i+1);
        }
        return ans;
    }
};
```



10.和为K的子数组

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回该数组中和为 `k` 的子数组的个数。

子数组是数组中元素的连续非空序列。

**示例 1：**

<pre><strong>输入：</strong>nums = [1,1,1], k = 2
<strong>输出：</strong>2
</pre>

**示例 2：**

<pre><strong>输入：</strong>nums = [1,2,3], k = 3
<strong>输出：</strong>2</pre>

思路：用一个哈希表记录每个前缀和出现的次数，只要有前缀和与K之差出现在哈希表中，则存在满足条件的子数组，且个数为哈希表项的值

```
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> prefixCount;
        prefixCount[0] = 1; // 前缀和为0出现一次，表示空子数组
        int sum = 0, ans = 0;

        for (int num : nums) {
            sum += num;
            if (prefixCount.find(sum - k) != prefixCount.end()) {
                ans += prefixCount[sum - k];
            }
            prefixCount[sum]++;
        }

        return ans;
    }
};
```
